# BackToTheBasic
[1. Java](#java) <br>
[2. Docker](#docker) <br>
[3. Kubernates](#kubernates) <br>
[4. Concept](#concept)<br>
[5. Project](#project)<br>
[6. Etc](#etc) <br>


## **Java**



## **Docker**
**컨테이너** 기반의 오픈소스 **가상화** 플랫폼<br> Linux기반의 Container Runtime 오픈소스. 
> **컨테이너:** 격리된 공간에서 프로세스가 동작하는 기술. 컨테이너는 이미지를 실행한 상태, 추가되거나 변하는 값은 컨테이너에 저장. <br>
> **이미지:** 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것, 상태값을 가지지 않고 변하지 않는다. 

**1. 특징**<br> Repository연계, 컨테이너 이미지를 중앙 레포지토리에 저장했다가 다른 환경에서 가져다가 사용가능. 컨테이너에는 모든 어플리케이션과 설치파일, 환경 설정 정보가 들어있어서 손쉽게 패키징 및 설치 가능<br>
`docker version` 실행 시 버전정보가 서버와 클라이언트로 나뉘어 있음. 도커 커맨드를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 받아 터널에 출력. 
`docker run [options] image[:tag|@digest] [command]`로 명령어 실행
run : 사용할 이미지가 저장되어 있는지 확인하고 없다면 다운로드 후 컨테이너 생성후 시작
exit : 쉘 종료하면 컨테이너도 종료
`docker build` 컨테이너를 만드는 명령어




## **Kubernates**
**컨테이너 운영환경**중 가장 널리 사용되는 솔루션(k8s). <br> 컨테이너를 적절한 서버에 배포해 주는 역할인 **스케쥴링**, 컨테이너가 정상적으로 작동하고 있는지 체크하고 문제가 있으면 **재기동**을 해주고, **모니터링**, 삭제관리 등 컨테이너에 대한 종합적 관리를 해주는 환경의 필요성으로 나옴
>**특징:** Go언어로 되어 있으며, 벤더나 플랫폼에 종속되지 않음. 퍼블릭 클라우드, 프라이빗 클라우드, 베어메탈(가상화 환경을 사용하지 않는 일반 서버 HW)에도 배포 가능 
>**Note:** 구글의 내부 컨테이너 서비스를 Borg라고 하고, 이를 오픈소스화 한것이 쿠버네티스

### [ 구성 ]
**마스터 :** 클러스터 전체를 관리하는 컨트롤러
**노드 :** 컨테이너가 배포되는 머신
**오브젝트 :** 기본 오브젝트 + 컨트롤러
쿠버네티스 시스템에서 영속성을 가지는 개체, 동작중인지, 이용할 리소스, 재구동 정책, 업그래이드 정책 정의. 
> **기본 오브젝트:**<br> 쿠버네티스에 의해 배포 및 관리되는 가장 기본적인 오브젝트는 컨테이너화 되어 배포되는 **Pod, Service, Volume, Namespace**로 구성되어 있다.
> **Pod :** 가장 기본적인 배포 단위, 컨테이너를 포함하는 단위. 쿠버네티스는 Pod라는 단위로 하나이상의 컨테이너를 포함하여 한번에 배포한다. Pod는 컨테이너를 가지고 있기 때문에 Containers를 정의한다. 
>> Pod내 컨테이너는 IP와 Port를 공유한다 
>> Pod내에 배포된 컨테이너 간에는 디스크 볼륨을 공유할 수 있다
>
>**Volume:** 영구적으로 파일을 저장해야하는 경우 스토리지 볼륨을 이용. Pod는 영구적이지 못함. 컨테이너가 리스타트 되거나 새로 배포될 때마다 로컬디스크는 Pod설정에 따라서 새롭게 정의하고 배포하여 디스크 내용이 유실된다. 
>> Volume은 Pod내의 컨테이너 간의 공유가 가능하다
>> **PersistentVolume & PersistentVolumeClaim :** 개발자는 Pod를 생성할때, 볼륨을 정의하고, 이 볼륨 정의 부분에 물리적 디스크에 대한 특성을 정의하는 것이 아니라 PVC를 지정하여, 관리자가 생성한 PV와 연결한다.  생성한 PV와 PVC를 Pod에 생성해서 연결(쿠버네티스 1.6에서 부터 Dynamic Provisioning (동적 생성) 기능을 지원.시스템 관리자가 별도로 디스크를 생성하고 PV를 생성할 필요 없이 PVC만 정의하면 이에 맞는 물리 디스크 생성 및 PV 생성을 자동화해주는 기능)
>> **StorageClass :** 스토리지 클래스는 PVC 정의시에, storageClassName에 적으면 PVC에 연결이 되고, 스토리지 클래스에 정해진 스펙에 따라서 물리 디스크와 PV를 생성하게 된다.  
  
> 
>**Service:** 보통 여러개의 pod를 하나의 IP와 Port로 묶어서 서비스를 제공한다. Pod의 경우에 지정되는 Ip가 랜덤하게 지정이 되고 리스타트 때마다 변하기 때문에 고정된 엔드포인트로 호출이 어렵다, 서비스는 지정된 IP로 생성이 가능하고, 여러 Pod를 묶어서 로드 밸런싱이 가능하며, 고유한 DNS 이름을 가질 수 있다. 로드벨런서가 추가/삭제된 Pod 목록을 유연하게 선택해 줄 수 있도록 도와주는 것이 라벨이며, 라벨 셀렉터를 이용한다.
>> **라벨 셀렉터 :** 어떤 pod를 서비스로 묶을 것인지 정의하는 것. 각 Pod를 생성할 때 메타데이터 정보 부분에 라벨을 정의할 수 있다.
>> **서비스타입 :** ClusterIP, LoadBalancer, NodePort, ExternalName
>**Namespace:** 쿠버네티스 클러스터내의 논리적인 분리단위. pod와 Service는 네임스페이스 별로 생성이나 고나리가 될 수 있고, 권한도 네임스페이스 별로 부여할 수 있음. 
> **Label:** 쿠버네티스의 리소스를 선택하는데 사용

> **컨트롤러**
> 4개의 기본 오브젝트로 설정 배포하는데 좀더 편리하게 관리하기 위함. Replication Controller (aka RC), Replication Set, DaemonSet, Job, StatefulSet, Deployment 이 있다.  
  >> **Replication Controller:**(복제 컨트롤러, RC) Pod를 관리해주는 역할. Replica의 수, Pod Selector, Pod Template 3가지로 구성.  Pod 생성은 Replication Controller (rc)를 생성하여, rc가 Pod 생성 및 컨트롤을 하도록 한다.
  >> **ReplicaSet:** (RS) Replication Controller 는 Equality 기반 Selector를 이용하는데 반해, Replica Set은 Set 기반의 Selector를 이용한다.  
  >>**Deployment:** Pod 배포를 위해서 RC를 생성하고 관리하는 역할을 하며, 특히 롤백을 위한 기존 버전의 RC 관리등 여러가지 기능을 포괄적으로 포함하고 있다.  
  >
 > **고급 컨트롤러**
 > 

## **Concept**

1. 인공지능 > 머신러닝 > 인공신경망 > 딥러닝

2. GAN
GAN에는 최대한 진짜 같은 데이터를 생성하려는 생성 모델과 진짜와 가짜를 판별하려는 분류 모델이 각각 존재하여 서로 적대적으로 학습 <br>
> **머신러닝(Machine learning)** 은 컴퓨터가 데이터를 학습하고 스스로 패턴을 찾아내 적절한 작업을 수행하도록 학습하는 알고리즘. 머신러닝은 크게 지도학습 (Supervised learning), 비지도학습 (Unsupervised learning), 강화학습 (Reinforcement learning)등으로 분류
>> **지도학습**은 정답이 주어진 상태에서 학습하는 알고리즘 -->  분류(classification)와 회귀생성(regression)
>> **비지도학습**은 정답이 주어지지 않은 상태에서 학습하는 알고리즘 -->  군집화(clustering)
>> **강화학습**은 현재의 상태(State)에서 어떤 행동(Action)을 취하는 것이 최적인지를 학습하는 것. 행동을 취할 때마다 외부 환경에서 보상(Reward)이 주어지는데, 이러한 보상을 최대화 하는 방향으로 학습이 진행
>
>

3. 운영체제
> **쉘**


4. 네트워크
> **OSI 7계층**
> **허브, 스위치, 라우터**
> 

5. 데이터베이스
> **정규화**
> 
6. Linux

7. C vs Java vs C++

8. 자료구조 
> **시간복잡도**
> **공간복잡도**
> **정렬기법**

<br>

## **Project**
 * [GAN 프로젝트](#gan-프로젝트) <br>
 * [핀테크 프로젝트](#핀테크-프로젝트) <br>


### GAN 프로젝트
1)  GAN 이란?
 : GAN은 생성자(Ganerateor, 이후 G)와 구분자(Discriminator, 이후 D) 2개의 신경망으로 구성되어 있는데, 생성자(G)는 하나의 신경망이 새로운 데이터인스턴스를 생성하고 구분자(D)는 데이터의 진위를 평가한다. 이 둘을함께 학습시키면서 진짜같은 가짜를 만들어내는 생성자(G)를 얻는다.

2) 한계
: 기존 GAN은 MNIST와 같이 비교적 단순한 DataSet에서는 만족스러운 결과값을 생성하였지만, CIFAR-10과 같은 복잡한 DataSet에서는 생성된 이미지 품질이 만족스럽지 못하였다.

3) 목적
:  학습 안정성과 이미지 품질을 향상시킨 새로운 구조의 GAN 제안. 처음부터 GAN을 여러 개 두고 각 GAN에 전체 Dataset이 아닌 일부 Dataset에 대해서만 학습을 수행하도록 하고 학습된 GAN들의 생성물을 병합하여 최종적으로 목표한 문제를 해결할 수 있는 응용 GAN을 생각해보았다. Fashion-MNIST 데이터 셋 이용.

4) 과정
:  1. 각 Label 별로 Dataset을 분할하여 구현하기, 2. 유사한 Label을 Grouping 하여 구현하기, 3. 무관한(유사하지 않은) Label을 Grouping하여 구현하기, 4. Dataset을 Label에 관계 없이 다른 클러스터링 알고리즘을 사용하여 클러스터링한 후 구현하기를 진행했다. 
: K-means Clustering 알고리즘을 사용하여 3또는 5개의 클러스터로 데이터셋을 분류하고, 각각의 클러스터를 각각의 GAN으로 학습시켜 나온 생성자(G)와 구분자(D)를 병합하였다.

5) 결과
: 유사한 Label을 3개씩 묶어서 학습을 진행했을 때 전체적으로 보다 향상된 이미지를 얻을 수 있으며 학습도 잘 진행되는 것을 확인할 수 있었다. 또한 Dataset의 Label을 구분하여 학습을 진행하였을 때 문제의 난이도가 낮아져서 중간에 발산하는 문제를 늦추는 등, 학습의 안정성을 향상시킬 수 있다는 결론을 낼 수 있었다.

<br>


### 핀테크 프로젝트 
1) 목적

2) 사용기술 

3) 


### FEP 
1) FEP
: Front End Processor. 내부 시스템과 외부 대외기관의 시스템을 연계해주는 대외계 솔루션

4. 증권사

5. 사이트 보안취약점 해결

6. 웹 개발 동아리

7. 앱 개발 동아리

9. Matelease 
 

##  **Etc**
> **yaml포맷:** Ain't Markup Language. 사람이 읽기 쉽게 되어 있는 형태로 표현하는 데이터 포맷. 데이터 직렬화 양식. 가독성에 포커싱 되어있음 
> 
